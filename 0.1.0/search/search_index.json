{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Panda Pytest Assertions is a library that provides a complex assertion mechanism for use when writing tests with pytest. The primary goal is to make test code more concise, readable, and maintainable.</p> <p>The library consists of two modules that can be used separately or together:</p> <ul> <li><code>assert_context</code> - used to assert that the block of code behaved as expected, raise or do not raise the exception and assert the value of a result;</li> <li><code>assert_object</code> - used to assert the content of the object, when simple <code>==</code> is not enough.</li> </ul>"},{"location":"#assert_context","title":"<code>assert_context</code>","text":"<p>This context manager asserts that a code block within a <code>with</code> block behaves according to expectations. It verifies whether an exception of a specific type was (or wasn't) raised within the block and whether the result of the block (settable by the user) matches the expected value. For example:</p> Python<pre><code>with assert_context(exception=ValueError, result='something') as context:\n    context.set('something')\n    raise ValueError\n</code></pre>"},{"location":"#assert_object","title":"<code>assert_object</code>","text":"<p>This function is used to assert the content of a Python object (and possibly nested objects) against provided expectations. It goes beyond simple equality checks using <code>==</code>. For instance:</p> Python<pre><code>asserted_object: Munch[str, Any] = Munch(\n    list_author='Jan Kowalski',\n    created_at=datetime(2020, 6, 8, 12, 30),\n    books=[\n        Munch(\n            name='Hobbit',\n            authors=['J. R. R. Tolkien'],\n            language='en',\n            translations={'pl': 1963, 'it': 1973},\n        ),\n        Munch(\n            name='Otworzy\u0107 po mojej \u015bmierci',\n            authors=['Abelard Giza'],\n            language='pl',\n            translations={},\n        ),\n    ],\n)\nexpectation = ObjectAttributes(\n    {\n        'created_at': Stringified('2020-06-08 12:30:00'),\n        'books': Unordered(\n            [\n                ObjectAttributes(\n                    {\n                        'name': 'Otworzy\u0107 po mojej \u015bmierci',\n                        'authors': ['Abelard Giza'],\n                        'translations': MappingSubset({}),\n                    },\n                ),\n                ObjectAttributes(\n                    {\n                        'name': 'Hobbit',\n                        'authors': Stringified(\"['J. R. R. Tolkien']\"),\n                        'language': 'en',\n                    },\n                ),\n            ],\n        ),\n    },\n)\n\nassert_object(expectation, asserted_object)\n</code></pre>"},{"location":"assert_context/","title":"<code>assert_context</code>","text":"<p>The <code>assert_context</code> module exposes a context manager that verifies whether code within a <code>with</code> block behaves as expected. It checks whether a specific exception type was (or wasn't) raised within the block and whether the result of the block (settable by the user) matches the expected value.</p> <p>Additionally, it provides the <code>AssertContext</code> class, which can be useful for typing in more complex scenarios, as it is the type returned by the <code>__enter__</code> method.</p>"},{"location":"assert_context/#basic-example","title":"Basic Example","text":"<p>The following code snippet demonstrates how to use <code>assert_context</code>. It asserts that the result of <code>fun()</code> will be <code>'something'</code> and that <code>bar()</code> will raise a <code>ValueError</code>.</p> Python<pre><code>with assert_context(exception=ValueError, result='something') as context:\n    context.set(fun())\n    bar()\n</code></pre>"},{"location":"assert_context/#parameters","title":"Parameters","text":"<p>The context manager defines three optional keyword parameters: <code>exception</code>, <code>result</code>, and <code>behaviour</code>. The pair of parameters (<code>exception</code>, <code>result</code>) is mutually exclusive with the <code>behaviour</code> parameter. If <code>behaviour</code> is set, the other parameters must remain unset.</p>"},{"location":"assert_context/#exception-parameter","title":"<code>exception</code> Parameter","text":"<ul> <li>If the <code>exception</code> parameter is set, the <code>with</code> block is expected to raise an exception of the provided type.</li> <li>If the <code>exception</code> parameter is NOT set, the <code>with</code> block is expected NOT to raise any exceptions.</li> </ul>"},{"location":"assert_context/#examples","title":"Examples","text":"<p>Code not raising any exceptions:</p> Python<pre><code>with assert_context():\n    ...\n\nwith assert_context(exception=ValueError):\n    raise ValueError\n</code></pre> <p>Code raising a <code>ValueError</code>:</p> Python<pre><code>with assert_context():\n    raise ValueError\n\nwith assert_context(exception=TypeError):\n    raise ValueError\n</code></pre> <p>Code calling <code>pytest.fail</code> (equivalent to <code>pytest.raises(ValueError)</code>):</p> Python<pre><code>with assert_context(exception=ValueError):\n    ...\n</code></pre>"},{"location":"assert_context/#result-parameter","title":"<code>result</code> Parameter","text":"<ul> <li>If the <code>result</code> parameter is set, its value is expected to be equal to the result of the <code>with</code> block.</li> <li>The <code>with</code> block result is set using the <code>set</code> method of an object yielded by the context manager.</li> <li>The comparison is performed using the <code>==</code> operator, with the <code>result</code> argument on the left side.</li> <li>If the <code>result</code> parameter is NOT set, the <code>set</code> method of the yielded object is expected not to be called at all.</li> </ul>"},{"location":"assert_context/#examples_1","title":"Examples","text":"<p>Code not raising any exceptions:</p> Python<pre><code>with assert_context() as context:\n    ...\n\nwith assert_context(result='something') as context:\n    context.set('something')\n</code></pre> <p>Code raising an <code>AssertionError</code>:</p> Python<pre><code>with assert_context() as context:\n    context.set('else')\n\nwith assert_context(result='something') as context:\n    context.set('else')\n\nwith assert_context(result='something') as context:\n    ...\n</code></pre>"},{"location":"assert_context/#combining-exception-and-result-parameters","title":"Combining <code>exception</code> and <code>result</code> Parameters","text":"<p>Both <code>exception</code> and <code>result</code> parameters can be set simultaneously to check more complex code.</p>"},{"location":"assert_context/#example","title":"Example","text":"<p>Code not raising any exceptions:</p> Python<pre><code>with assert_context(exception=ValueError, result='something') as context:\n    context.set('something')\n    raise ValueError\n</code></pre>"},{"location":"assert_context/#behaviour-parameter","title":"<code>behaviour</code> Parameter","text":"<ul> <li>If <code>behaviour</code> is set to an exception type, it is equivalent to setting <code>exception</code> to the same value and leaving <code>result</code> unset.</li> <li>If <code>behaviour</code> is set to any other value, it is treated as the value of <code>result</code>, and the <code>exception</code> parameter remains unset.</li> </ul>"},{"location":"assert_context/#examples_2","title":"Examples","text":"<p>Code not raising any exceptions:</p> Python<pre><code>with assert_context(behaviour=ValueError) as context:\n    raise ValueError\n\nwith assert_context(result='something') as context:\n    context.set('something')\n</code></pre> <p>Code raising exceptions:</p> Python<pre><code>with assert_context(behaviour=ValueError) as context:\n    context.set('else')\n\nwith assert_context(result='something') as context:\n    raise ValueError\n</code></pre>"},{"location":"assert_object/","title":"<code>assert_object</code>","text":"<p>The <code>assert_object</code> module exposes a function that asserts whether the content of a Python object (including possibly nested objects) fulfills provided expectations.</p>"},{"location":"assert_object/#basic-example","title":"Basic Example","text":"<p>Consider the following code snippet, which asserts the return value of <code>fun()</code> against specific expectations.</p> <ul> <li>The object must have at least two attributes: <code>created_at</code> and <code>books</code>.</li> <li>The <code>created_at</code> attribute, when stringified, must match <code>'2020-06-08 12:30:00'</code>.</li> <li>The <code>books</code> attribute must be an iterable with exactly two elements.</li> <li>The order of the <code>books</code> elements does not matter.</li> <li>One of the <code>books</code> elements must have at least <code>name</code>, <code>authors</code>, and <code>translations</code> attributes.</li> <li>Another <code>books</code> element must have at least <code>name</code>, <code>authors</code>, and <code>language</code> attributes.</li> <li>The values of the <code>books</code> elements' attributes are also checked against specified expectations.</li> </ul> Python<pre><code>expectation = ObjectAttributes(\n    {\n        'created_at': Stringified('2020-06-08 12:30:00'),\n        'books': Unordered(\n            [\n                ObjectAttributes(\n                    {\n                        'name': 'Otworzy\u0107 po mojej \u015bmierci',\n                        'authors': ['Abelard Giza'],\n                        'translations': MappingSubset({}),\n                    },\n                ),\n                ObjectAttributes(\n                    {\n                        'name': 'Hobbit',\n                        'authors': Stringified(\"['J. R. R. Tolkien']\"),\n                        'language': 'en',\n                    },\n                ),\n            ],\n        ),\n    },\n)\n\nassert_object(expectation, foo())\n</code></pre> <p>Example of an object that fulfills the above expectation:</p> Python<pre><code>Munch(\n    list_author='Jan Kowalski',\n    created_at=datetime(2020, 6, 8, 12, 30),\n    books=[\n        Munch(\n            name='Hobbit',\n            authors=['J. R. R. Tolkien'],\n            language='en',\n            translations={'pl': 1963, 'it': 1973},\n        ),\n        Munch(\n            name='Otworzy\u0107 po mojej \u015bmierci',\n            authors=['Abelard Giza'],\n            language='pl',\n            translations={},\n        ),\n    ],\n)\n</code></pre>"},{"location":"assert_object/10.asserting/","title":"Asserting Objects","text":"<p>The module provides two ways of asserting objects.</p>"},{"location":"assert_object/10.asserting/#using-the-assert_object-function","title":"Using the <code>assert_object</code> Function","text":"<p>The most basic way to assert an object is by using the following function:</p> Python<pre><code>def assert_object(\n    expectation: Any,\n    object_: Any,\n    *,\n    asserter_factory: type[AsserterFactoryProtocol] = BuiltInAsserterFactory,\n) -&gt; None: ...\n</code></pre> <p>In basic usage, it accepts an expectation and an object to be asserted. For more complicated use cases, it also accepts a custom asserter factory \u2014 a class used to create asserters that ensure a given type of expectation is fulfilled by the provided object.</p> <p>The function doesn't return anything but raises an <code>AssertionError</code> with an error description as a message when the object does not fulfill the expectation.</p> <p>For more information on asserters and factories, see Asserters.</p>"},{"location":"assert_object/10.asserting/#using-the-expectation-class","title":"Using the <code>Expectation</code> Class","text":"<p>The module also provides an <code>Expectation</code> class, which overrides the <code>__eq__</code> magic method to perform object assertion.</p> <p>It is initialized with the expectation and optionally an asserter factory to be used. Then it can be compared to an object that should fulfill the expectation.</p> <p>The comparison will return <code>True</code> if the object fulfills the expectation and <code>False</code> otherwise.</p> Python<pre><code>assert Expectation(expectation) == object_\nassert Expectation(expectation) != object_\n</code></pre> <p>This approach is mostly useful in combination with <code>assert_context</code>. The following code checks that the return value of <code>foo()</code> fulfills the <code>expectation</code>:</p> Python<pre><code>with assert_context(result=Expectation(expectation)) as context:\n    context.set(foo())\n</code></pre>"},{"location":"assert_object/20.expectations/","title":"Expectations","text":"<p>An expectation describes the desired content of an object. It can be any class, as long as there is an asserter registered for it in the used asserter factory.</p>"},{"location":"assert_object/20.expectations/#out-of-the-box-expectations","title":"Out-of-the-Box Expectations","text":"<p>The module comes with several generic asserters that support the following expectation types:</p> <ol> <li> <p>Built-in Classes:</p> <ul> <li><code>Mapping</code> (from <code>collections.abc</code>)</li> <li><code>list</code> or <code>tuple</code></li> <li><code>set</code></li> </ul> </li> <li> <p>Special Expectation Classes (importable from <code>panda_pytest_assertions.assert_object</code>):</p> <ul> <li><code>Stringified</code></li> <li><code>Unordered</code></li> <li><code>MappingSubset</code></li> <li><code>ObjectAttributes</code></li> <li><code>WithType</code></li> </ul> </li> </ol> <p>Additionally, any object can be used as an expectation, and it will be compared using the <code>==</code> operator to the object. This fallback mechanism is used if the expectation does not match any of the specific supported types.</p>"},{"location":"assert_object/20.expectations/#any-object","title":"Any Object","text":"<p>Any object can be used as an expectation. This is especially useful for primitive types, but it can also be applied to anything that implements a meaningful <code>__eq__</code> method. The assertion passes if the asserted object equals the expectation (<code>assert expectation == object_</code>).</p> Python<pre><code>assert_object(\n    expectation=True,\n    object_=1,\n)\n</code></pre> <p>This asserter should always be placed at the end of the factory registry, as it matches any kind of object and will shadow other asserters otherwise.</p>"},{"location":"assert_object/20.expectations/#stringified","title":"<code>Stringified</code>","text":"<p>The simplest expectation is the <code>Stringified</code> expectation. While not very useful by itself, it becomes valuable when building complex expectations. It asserts that the stringified value of the asserted object (<code>str(object_)</code>) is equal to a given string.</p> <p>Example usage:</p> Python<pre><code>assert_object(\n    expectation=Stringified('2020-06-08 12:30:00'),\n    object_=datetime(2020, 6, 8, 12, 30),\n)\n</code></pre>"},{"location":"assert_object/20.expectations/#mapping","title":"<code>Mapping</code>","text":"<p>The <code>Mapping</code> expectation is used to assert mappings (e.g., dictionaries). It defines a mapping between keys and expectations for the values assigned to those keys. For the assertion to succeed:</p> <ul> <li>The asserted object must contain the exact same keys as the expectation (no more, no less).</li> <li>The values assigned to specific keys must fulfill the expectations defined for those keys in the mapping expectation.</li> </ul> <p>Example usage:</p> Python<pre><code>assert_object(\n    expectation={\n        2: {'env': 'water', 'fur': False},\n        1: Stringified(\"{'color': 'brown', 'legs': 4}\"),\n    },\n    object_={\n        1: {'color': 'brown', 'legs': 4},\n        2: {'fur': False, 'env': 'water'},\n    },\n)\n</code></pre> <p>Notes:</p> <ul> <li>The asserted object must be an instance of <code>collections.abc.Mapping</code>.</li> <li>Although dictionaries in Python are ordered, the order of keys in mappings does not matter for this type of expectation.</li> <li>Any supported expectation type can be used as the value in the mapping expectation.</li> <li>Keys of the expectation and asserted object are extracted for comparison using <code>.keys()</code>.</li> <li>Keys and values are extracted from the expectation using <code>.items()</code>.</li> <li>Values are extracted from the object using <code>object_[key_from_expectation]</code>.</li> </ul>"},{"location":"assert_object/20.expectations/#list-or-tuple","title":"<code>list</code> or <code>tuple</code>","text":"<p>The <code>list</code> or <code>tuple</code> expectation is used to assert iterables. It consists of ordered elements' expectations. For the assertion to succeed:</p> <ul> <li>The asserted object must contain the same number of elements as the expectation.</li> <li>The element at index <code>i</code> in the asserted object must fulfill the expectation's element at the same index.</li> </ul> <p>Example usage:</p> Python<pre><code>assert_object(\n    expectation=[\n        {'env': 'water', 'fur': False},\n        Stringified(\"{'color': 'brown', 'legs': 4}\"),\n    ],\n    object_=[\n        {'fur': False, 'env': 'water'},\n        {'color': 'brown', 'legs': 4},\n    ],\n)\n\nassert_object(\n    expectation=['a', 'b', 'c'],\n    object_='abc',  # string is iterable\n)\n</code></pre> <p>Notes:</p> <ul> <li>The asserted object must be an instance of <code>collections.abc.Iterable</code>.</li> <li>The order of elements matters.</li> <li>Any supported expectation type can be used as an element in this expectation.</li> </ul>"},{"location":"assert_object/20.expectations/#set-or-unordered","title":"<code>set</code> or <code>Unordered</code>","text":"<p>The <code>set</code> or <code>Unordered</code> expectation is used to assert iterables. It is either a set of expectations or an <code>Unordered</code> object created from a list of expectations. For the assertion to succeed:</p> <ul> <li>The asserted object must contain the same number of elements as the expectation.</li> <li>Each element in the asserted object must fulfill one unique expectation.</li> </ul> <p>Example usage:</p> Python<pre><code>assert_object(\n    expectation={'water', 'fire', 'earth', 'air'},\n    object_=[\n        'fire',\n        'earth',\n        'water',\n        'air',\n    ],\n)\n\nassert_object(\n    expectation={'c', 'a', 'b'},\n    object_='abc',  # string is iterable\n)\n\nassert_object(\n    expectation=Unordered([Stringified('4'), 3, 2]),\n    object_=[2, 4, 3],\n)\n</code></pre> <p>Notes:</p> <ul> <li>The asserted object must be an instance of <code>collections.abc.Iterable</code>.</li> <li>Any supported expectation type can be used as an element in this expectation.</li> <li>The comparison logic processes all elements of the expectation in the order they are returned (which is not guaranteed by the set!). It tries to find the first element in the asserted object that fulfills the expectation. If successful, the expectation and the matched element are no longer considered. Be cautious when expectations match multiple elements; the order matters.</li> </ul> <p>Example with potential behavior change due to order:</p> Python<pre><code>assert_object(\n    expectation=Unordered([Stringified('1'), 1]),\n    object_=[1, '1']\n)\n</code></pre> <p>The first expectation matches the first element of an object (<code>str(1) == '1'</code>), so the asserter is unable to find a match for the second expectation, as <code>1 != '1'</code>. If the order of expectations in the list were changed, the assertion would pass.</p>"},{"location":"assert_object/20.expectations/#mappingsubset","title":"<code>MappingSubset</code>","text":"<p>The <code>MappingSubset</code> expectation is used to assert mappings (e.g., dictionaries). It is initialized with a mapping between keys and expectations for the values assigned to those keys. For the assertion to succeed:</p> <ul> <li>The asserted object must contain at least the same keys as the expectation (but can contain more).</li> <li>The values assigned to specific keys must fulfill the expectations defined for those keys in the mapping expectation.</li> </ul> <p>Example usage:</p> Python<pre><code>assert_object(\n    expectation=MappingSubset(\n        {\n            2: {'env': 'water', 'fur': False},\n            1: Stringified(\"{'color': 'brown', 'legs': 4}\"),\n        },\n    ),\n    object_={\n        1: {'color': 'brown', 'legs': 4},\n        3: 'anything',\n        2: {'fur': False, 'env': 'water'},\n    },\n)\n</code></pre> <p>Notes:</p> <ul> <li>The asserted object must be an instance of <code>collections.abc.Mapping</code>.</li> <li>Although dictionaries in Python are ordered, the order of keys in mappings does not matter for this type of expectation.</li> <li>Any supported expectation type can be used as the value in the mapping expectation.</li> <li>Keys of the expectation and asserted object are extracted for comparison using <code>.keys()</code>.</li> <li>Keys and values are extracted from the expectation using <code>.items()</code>.</li> <li>Values are extracted from the object using <code>object_[key_from_expectation]</code>.</li> </ul>"},{"location":"assert_object/20.expectations/#objectattributes","title":"<code>ObjectAttributes</code>","text":"<p>The <code>ObjectAttributes</code> expectation is used to assert any object. It is initialized with a mapping between attribute names and expectations for their values. For the assertion to succeed:</p> <ul> <li>The asserted object must contain at least the attributes defined in the expectation (but can contain more).</li> <li>The values assigned to specific attributes must fulfill the expectations defined for those attribute names in the mapping expectation.</li> </ul> <p>Example usage:</p> Python<pre><code>assert_object(\n    expectation=ObjectAttributes(\n        {\n            'abc': {'env': 'water', 'fur': False},\n            'xyz': Stringified(\"{'color': 'brown', 'legs': 4}\"),\n        },\n    ),\n    object_=Munch(\n        xyz={'color': 'brown', 'legs': 4},\n        another='anything',\n        abc={'fur': False, 'env': 'water'},\n    ),\n)\n</code></pre> <p>Notes:</p> <ul> <li>The asserted object can be of any type.</li> <li>The order of keys in mappings does not matter.</li> <li>Keys and values are extracted from the expectation using <code>.items()</code>.</li> <li>Any supported expectation type can be used as the value in the main expectation.</li> <li>Checking whether an attribute exists in an object is done using the <code>hasattr</code> function.</li> <li>Values for attributes are extracted from the object using <code>getattr(object_, key_from_expectation)</code>.</li> </ul>"},{"location":"assert_object/20.expectations/#withtype","title":"<code>WithType</code>","text":"<p>The <code>WithType</code> expectation is used to assert any object. It is initialized with an inner expectation, an expected type name, and optionally an expected type module fully qualified name. For the assertion to succeed:</p> <ul> <li>The asserted object must fulfill the inner expectation.</li> <li>Its type must be named according to the expectation.</li> <li>The type must be defined in the expected module (if set in the main expectation).</li> </ul> <p>Example usage:</p> Python<pre><code>assert_object(\n    expectation=WithType(\n        Stringified(\"Munch({'color': 'brown', 'legs': 4})\"),\n        'Munch',\n        'munch',\n    ),\n    object_=Munch(color='brown', legs=4),\n)\n</code></pre> <p>Notes:</p> <ul> <li>The asserted object can be of any type.</li> <li>The name of the asserted object's type is extracted using <code>object_.__class__.__name__</code>.</li> <li>The name of a module of the asserted object's type is extracted using <code>object_.__class__.__module__</code>.</li> <li>If the expected module name is not set (is set to <code>None</code>), the check for the module name is not performed.</li> </ul> <p>The <code>WithType</code> class provides the helper function <code>with_type</code>, which allows for easier setting of the expected type and module name. The function accepts from 0 to 2 positional parameters and returns another function that creates the <code>WithType</code> object.</p> <p>Examples:</p> Python<pre><code>with_type()(some_expectation)\nwith_type(some_type)(some_expectation)\nwith_type('some_type_name')(some_expectation)\nwith_type('some_type_name', 'some_module_name')(some_expectation)\n</code></pre> <p>In all cases, the inner expectation of <code>WithType</code> will be set to <code>some_expectation</code>, and the expected type name and module name will be set according to the rules described below.</p> <ul> <li>If no parameters are provided, the values for the expected type name and module name will be extracted from <code>some_expectation</code>.</li> <li>If a single parameter is passed and it is a type, the values will be extracted from this type.</li> <li>If a single parameter is passed and it is a string it will be used as an expected type name and the expected module name will be left unset.</li> <li>In case two string parameters are passed, they will be used as expected type name and expected module name, respectively.</li> </ul> <p>The above example can be rewritten as follows:</p> Python<pre><code>assert_object(\n    expectation=with_type(Munch)(Stringified(\"Munch({'color': 'brown', 'legs': 4})\")),\n    object_=Munch(color='brown', legs=4),\n)\n</code></pre>"},{"location":"assert_object/30.using_yaml/","title":"Using YAML","text":"<p>For handling very complex objects, especially in the context of end-to-end (E2E) tests, it can be highly beneficial to store expectations in separate YAML files. This module provides helper methods to both dump expectations into a YAML string and load them from a YAML string.</p> <p>Any expectation supported by this module can be converted into YAML using the <code>expectation_to_yaml</code> function. Let's take a look at an example:</p> Python<pre><code>expectation = ObjectAttributes(\n    {\n        'created_at': Stringified('2020-06-08 12:30:00'),\n        'books': Unordered(\n            [\n                ObjectAttributes(\n                    {\n                        'name': 'Otworzy\u0107 po mojej \u015bmierci',\n                        'authors': ['Abelard Giza'],\n                        'translations': MappingSubset({}),\n                    },\n                ),\n                ObjectAttributes(\n                    {\n                        'name': 'Hobbit',\n                        'authors': Stringified(\"['J. R. R. Tolkien']\"),\n                        'language': 'en',\n                    },\n                ),\n            ],\n        ),\n    },\n)\n\nyaml_string = expectation_to_yaml(expectation)\n</code></pre> <p>The resulting <code>yaml_string</code> will have the following content:</p> YAML<pre><code>!ObjectAttributes\nbooks: !Unordered\n- !ObjectAttributes\n  authors:\n  - Abelard Giza\n  name: \"Otworzy\\u0107 po mojej \\u015Bmierci\"\n  translations: !MappingSubset {}\n- !ObjectAttributes\n  authors: !Stringified '[''J. R. R. Tolkien'']'\n  language: en\n  name: Hobbit\ncreated_at: !Stringified '2020-06-08 12:30:00'\n</code></pre> <p>You can also load a YAML string back into expectation objects using the <code>expectation_from_yaml</code> function:</p> Python<pre><code>expectation = expectation_from_yaml(yaml_string)\n</code></pre> <p>Keep in mind that the loaded expectation may not be exactly identical to the original one before dumping, but it will be functionally equivalent.</p>"},{"location":"assert_object/40.asserters/","title":"Asserters","text":"<p>Asserters are the core of this module's business logic. They are the objects responsible for checking whether other objects fulfill a given expectation.</p> <p>Each asserter must adhere to the following protocol:</p> Python<pre><code>class AsserterProtocol(Protocol):\n    \"\"\"\n    Asserter that checks whether the given expectation is fulfilled by an object.\n    \"\"\"\n\n    expectation: Any\n    asserter_factory: 'type[AsserterFactoryProtocol]'\n\n    def __init__(\n        self,\n        asserter_factory: 'type[AsserterFactoryProtocol]',\n        expectation: Any,\n    ) -&gt; None: ...\n\n    @classmethod\n    def matches(cls, expectation: Any) -&gt; bool:\n        \"\"\"\n        Determines whether the provided expectation can be handled by this asserter.\n\n        :param expectation: the expectation to be tested\n        \"\"\"\n\n    def assert_object(self, object_: Any) -&gt; None:\n        \"\"\"\n        Asserts whether the expectation is fulfilled by an object.\n\n        :param object_: the object to be tested\n        \"\"\"\n</code></pre>"},{"location":"assert_object/40.asserters/#asserter-factories","title":"Asserter Factories","text":"<p>When asserting objects, asserters are created from expectations using factories. The factory maintains an ordered sequence of asserter classes. When creating an asserter for a specific expectation, the factory iterates over the classes and uses the first one for which the <code>matches</code> method returns <code>True</code>.</p> <p>The module provides a <code>BuiltInAsserterFactory</code> that includes all out-of-the-box asserters. Additionally, there is a blank factory called <code>AsserterFactory</code> that does not have any asserters registered.</p> <p>To add an asserter to the factory, use the <code>register_asserter</code> class method with the following signature:</p> Python<pre><code>def register_asserter(\n    asserter: type[AsserterProtocol],\n    *,\n    after: type[AsserterProtocol] | None = None,\n    before: type[AsserterProtocol] | None = None,\n) -&gt; None:\n</code></pre> <p>The asserter is registered at the earliest possible position. If <code>after</code> and <code>before</code> parameters are not set, it is added to the beginning of the list to be matched when creating an asserter for expectations. The <code>after</code> and <code>before</code> parameters allow you to specify constraints on the asserter's position.</p> <p>When creating a subclass of a factory, it initially uses the same asserters collection as its base class. However, once the first asserter is registered, the collection from the base class is copied before adding new asserters.</p>"},{"location":"assert_object/generating_expectation/","title":"Generating Expectations","text":"<p>When dealing with very complex objects, especially in the context of end-to-end (E2E) tests, manually writing expectations can be cumbersome. In such scenarios, it may be beneficial to automatically generate expectations from an existing object (produced by tested code), review them, and store them as input for the test. This can be achieved using the <code>generators</code> submodule available in this module.</p> <p>The internal structure of generators closely resembles that of the main module:</p> <ul> <li>Instead of an \"expectation,\" there is an \"expectation definition\" - an object that defines the structure of the generated expectation.</li> <li>Instead of an \"asserter,\" there is a \"generator\" - a class that implements the logic for generating expectations based on a specific definition.</li> <li>Finally, instead of an \"asserter factory,\" there is a \"generator factory\" - a class that creates a generator for a specific generator definition.</li> </ul> <p>Expectation definitions are necessary because there is no universal way to represent an object in an expectation. For example, every object might be stringified or used as-is. If you want to generate an <code>ObjectAttributes</code> expectation, it would be atypical to include all attributes for asserting. Therefore, expectation definitions help define the structure of a generated expectation, determine the appropriate expectation type, and specify the values to include.</p> <p>The function used to generate an expectation is called <code>generate_expectation</code>. It accepts the following parameters:</p> <ul> <li>the object from which expectation values will be taken,</li> <li>the definition describing the expectation structure,</li> <li>optionally, a custom generator factory.</li> </ul> <p>Here's an example:</p> Python<pre><code>object_: Munch[str, Any] = Munch(\n    list_author='Jan Kowalski',\n    created_at=datetime(2020, 6, 8, 12, 30),\n    books=[\n        Munch(\n            name='Hobbit',\n            authors=['J. R. R. Tolkien'],\n            language='en',\n            translations={'pl': 1963, 'it': 1973},\n        ),\n        Munch(\n            name='Otworzy\u0107 po mojej \u015bmierci',\n            authors=['Abelard Giza'],\n            language='pl',\n        ),\n    ],\n)\ndefinition = with_type_def(include_module=True)(\n    ObjectAttributesDef(\n        {\n            'created_at': StringifiedDef,\n            'books': UniformUnorderedDef(\n                UnionDef(\n                    ObjectAttributesDef(\n                        {\n                            'name': EqualityDef,\n                            'authors': StringifiedDef,\n                            'language': EqualityDef,\n                            'translation': UniformMappingSubsetDef(\n                                EqualityDef,\n                                with_type_def(include_module=False)(EqualityDef),\n                            ),\n                        },\n                    ),\n                    ObjectAttributesDef(\n                        {\n                            'name': EqualityDef,\n                            'authors': StringifiedDef,\n                            'language': EqualityDef,\n                        },\n                    ),\n                ),\n            ),\n        },\n    ),\n)\nexpectation = generate_expectation(object_, definition)\n</code></pre> Generated Expectation<pre><code>!WithType\nexpectation: !ObjectAttributes\n  books: !Unordered\n  - !ObjectAttributes\n    authors: !Stringified '[''J. R. R. Tolkien'']'\n    language: en\n    name: Hobbit\n  - !ObjectAttributes\n    authors: !Stringified '[''Abelard Giza'']'\n    language: pl\n    name: \"Otworzy\\u0107 po mojej \\u015Bmierci\"\n  created_at: !Stringified '2020-06-08 12:30:00'\nexpected_type_module: munch\nexpected_type_name: Munch\n</code></pre>"},{"location":"assert_object/generating_expectation/10.definition/","title":"Expectation Definitions","text":"<p>An expectation definition describes the desired structure of an expectation that will be generated from a values object. It can be any class, as long as there is an expectation generator registered for it in the used generator factory.</p>"},{"location":"assert_object/generating_expectation/10.definition/#out-of-the-box-expectations","title":"Out-of-the-Box Expectations","text":"<p>The module comes with several generic expectation generators that support the following expectation definition types:</p> <ol> <li> <p>Built-in Classes:</p> <ul> <li><code>Mapping</code> (from <code>collections.abc</code>)</li> <li><code>list</code> or <code>tuple</code></li> </ul> </li> <li> <p>Special Expectation Classes (importable from <code>panda_pytest_assertions.assert_object.generators</code>):</p> <ul> <li><code>EqualityDef</code></li> <li><code>StringifiedDef</code></li> <li><code>MappingDef</code></li> <li><code>MappingSubsetDef</code></li> <li><code>UniformMappingDef</code></li> <li><code>UniformMappingSubsetDef</code></li> <li><code>UniformUnorderedDef</code></li> <li><code>UniformOrderedDef</code></li> <li><code>ObjectAttributesDef</code></li> <li><code>OfTypeDef</code></li> <li><code>WithTypeDef</code></li> <li><code>UnionDef</code></li> </ul> </li> </ol>"},{"location":"assert_object/generating_expectation/10.definition/#equalitydef","title":"<code>EqualityDef</code>","text":"<p>The simplest expectation definition is <code>EqualityDef</code>. While not very useful by itself, it becomes valuable when building complex definitions. It means that the object will be used as an expectation as is.</p> <p>Example usage:</p> Python<pre><code>object_ = {\n    1: {'color': 'brown', 'legs': 4},\n    2: {'fur': False, 'env': 'water'},\n}\ndefinition = EqualityDef\n</code></pre> Generated expectation<pre><code>1:\n  color: brown\n  legs: 4\n2:\n  env: water\n  fur: false\n</code></pre> <p>Notes:</p> <ul> <li>It can be used as a class or as an instance of the class.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#stringifieddef","title":"<code>StringifiedDef</code>","text":"<p>Another trivial definition, mostly used as a nested one, is <code>StringifiedDef</code>. It generates a <code>Stringified</code> expectation with the value equal to the stringified object.</p> <p>Example usage:</p> Python<pre><code>object_ = {\n    1: {'color': 'brown', 'legs': 4},\n    2: {'fur': False, 'env': 'water'},\n}\ndefinition = StringifiedDef\n</code></pre> Generated expectation<pre><code>!Stringified '{1: {''color'': ''brown'', ''legs'': 4}, 2: {''fur'': False, ''env'': ''water''}}'\n</code></pre> <p>Notes:</p> <ul> <li>It can be used as a class or as an instance of the class.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#mapping","title":"<code>Mapping</code>","text":"<p>Any <code>Mapping</code> can be used as an expectation definition. The definition is a mapping between keys from the object and definitions that will be used for respective values. It is used to generate an expectation that is also a mapping.</p> <p>Example usage:</p> Python<pre><code>object_ = {\n    1: {'color': 'brown', 'legs': 4},\n    2: {'fur': False, 'env': 'water'},\n}\ndefinition = {\n    2: StringifiedDef,\n    1: EqualityDef,\n}\n</code></pre> Generated expectation<pre><code>1:\n  color: brown\n  legs: 4\n2: !Stringified '{''fur'': False, ''env'': ''water''}'\n</code></pre> <p>Notes:</p> <ul> <li>Values object must be an instance of <code>collections.abc.Mapping</code>.</li> <li>Values object must contain the exact same keys as the definition (no more, no less).</li> <li>Although dictionaries in Python are ordered, the order of keys in mappings does not matter for this type of definition.</li> <li>Any supported expectation definition can be used as the value in the definition.</li> <li>Keys of the definition and values object are extracted for comparison using <code>.keys()</code>.</li> <li>Keys and values are extracted from the definition using <code>.items()</code>.</li> <li>Values are extracted from the object using <code>object_[key_from_definition]</code>.</li> <li>Keys in the expectation will be used as-is without any modification.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#mappingdef","title":"<code>MappingDef</code>","text":"<p><code>MappingDef</code> is a slight modification of using a simple mapping. It is also used to generate a mapping expectation, but the difference is that keys of the values object are not copied to the expectation as is; instead, they are processed through a custom definition (one for all keys).</p> <p>Example usage:</p> Python<pre><code>object_ = {\n    1: {'color': 'brown', 'legs': 4},\n    2: {'fur': False, 'env': 'water'},\n}\ndefinition = MappingDef(\n    StringifiedDef,\n    {\n        2: StringifiedDef,\n        1: EqualityDef,\n    },\n)\n</code></pre> Generated expectation<pre><code>!Stringified '2': !Stringified '{''fur'': False, ''env'': ''water''}'\n!Stringified '1':\n  color: brown\n  legs: 4\n</code></pre> <p>Notes:</p> <ul> <li>Values object must be an instance of <code>collections.abc.Mapping</code>.</li> <li>Values object must contain the exact same keys as the definition (no more, no less).</li> <li>Although dictionaries in Python are ordered, the order of keys in mappings does not matter for this type of definition.</li> <li>Any supported expectation definition can be used as the value in the definition.</li> <li>Keys of the definition and values object are extracted for comparison using <code>.keys()</code>.</li> <li>Keys and values are extracted from the definition using <code>.items()</code>.</li> <li>Values are extracted from the object using <code>object_[key_from_definition]</code>.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#mappingsubsetdef","title":"<code>MappingSubsetDef</code>","text":"<p><code>MappingSubsetDef</code> is a slight modification of a <code>MappingDef</code>. It generates a <code>MappingSubset</code> expectation instead of a dictionary, and values object can have more keys than the definition, which will just be skipped.</p> <p>Example usage:</p> Python<pre><code>object_ = {\n    1: {'color': 'brown', 'legs': 4},\n    2: {'fur': False, 'env': 'water'},\n}\ndefinition = MappingSubsetDef(\n    StringifiedDef,\n    {\n        2: StringifiedDef,\n    },\n)\n</code></pre> Generated expectation<pre><code>!MappingSubset\n!Stringified '2': !Stringified '{''fur'': False, ''env'': ''water''}'\n</code></pre> <p>Notes:</p> <ul> <li>Values object must be an instance of <code>collections.abc.Mapping</code>.</li> <li>Values object must have at least the same keys as the definition (it can contain more).</li> <li>Although dictionaries in Python are ordered, the order of keys in mappings does not matter for this type of definition.</li> <li>Any supported expectation definition can be used as the value in the definition.</li> <li>Keys and values are extracted from the definition using <code>.items()</code>.</li> <li>Values are extracted from the object using <code>object_[key_from_definition]</code>.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#uniformmappingdef","title":"<code>UniformMappingDef</code>","text":"<p><code>UniformMappingDef</code> is a slight modification of a <code>MappingDef</code>. It also generates a mapping expectation, but the difference is that it accepts a single definition that will be used for all values.</p> <p>Example usage:</p> Python<pre><code>object_ = {\n    1: {'color': 'brown', 'legs': 4},\n    2: {'fur': False, 'env': 'water'},\n}\n\ndefinition = UniformMappingDef(\n    StringifiedDef,  # definition for keys\n    StringifiedDef,  # definition for values\n)\n</code></pre> Generated expectation<pre><code>!Stringified '1': !Stringified '{''color'': ''brown'', ''legs'': 4}'\n!Stringified '2': !Stringified '{''fur'': False, ''env'': ''water''}'\n</code></pre> <p>Notes:</p> <ul> <li>Values object must be an instance of <code>collections.abc.Mapping</code>.</li> <li>Any supported expectation definition can be used as the value in the definition.</li> <li>Keys and values are extracted from the values object using <code>.items()</code>.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#uniformmappingsubsetdef","title":"<code>UniformMappingSubsetDef</code>","text":"<p><code>UniformMappingSubsetDef</code> is a slight modification of <code>UniformMappingDef</code>. The difference is that it generates a <code>MappingSubset</code> expectation instead of a dictionary.</p> <p>Example usage:</p> Python<pre><code>object_ = {\n    1: {'color': 'brown', 'legs': 4},\n    2: {'fur': False, 'env': 'water'},\n}\n\ndefinition = UniformMappingSubsetDef(\n    StringifiedDef,  # definition for keys\n    StringifiedDef,  # definition for values\n)\n</code></pre> Generated expectation<pre><code>!MappingSubset\n!Stringified '1': !Stringified '{''color'': ''brown'', ''legs'': 4}'\n!Stringified '2': !Stringified '{''fur'': False, ''env'': ''water''}'\n</code></pre> <p>Notes:</p> <ul> <li>Values object must be an instance of <code>collections.abc.Mapping</code>.</li> <li>Any supported expectation definition can be used as the value in the definition.</li> <li>Keys and values are extracted from the values object using <code>.items()</code>.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#list-or-tuple","title":"<code>list</code> or <code>tuple</code>","text":"<p>Any <code>list</code> or <code>tuple</code> can be used as an expectation definition. The definition is an iterable of definitions for values object elements. It is used to generate an expectation that is also a list or a tuple.</p> <p>Example usage:</p> Python<pre><code>object_ = [\n    {'color': 'brown', 'legs': 4},\n    {'fur': False, 'env': 'water'},\n]\n\ndefinition = [\n    StringifiedDef,\n    EqualityDef,\n]\n</code></pre> Generated expectation<pre><code>- !Stringified '{''color'': ''brown'', ''legs'': 4}'\n- env: water\n  fur: false\n</code></pre> <p>Notes:</p> <ul> <li>Values object must be an instance of <code>collections.abc.Iterable</code>.</li> <li>Values object must contain the exact number of elements as the definition.</li> <li>Any supported expectation definition can be used as the element in the definition.</li> <li>The order of the elements in the definition matters; the first one will be used for the first element in the values object, and so on.</li> <li>The produced expectation will be of the same type as the definition.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#uniformordereddef","title":"<code>UniformOrderedDef</code>","text":"<p><code>UniformOrderedDef</code> is a slight modification of using a simple list or tuple. It also generates a list or tuple expectation, but the difference is that it accepts a single definition that will be used for all elements. It also has a keyword-only parameter that decides the result expectation type (defaults to <code>list</code>).</p> <p>Example usage:</p> Python<pre><code>object_ = [\n    {'color': 'brown', 'legs': 4},\n    {'fur': False, 'env': 'water'},\n]\n\ndefinition = UniformOrderedDef(StringifiedDef, expectation_type=list)\n</code></pre> Generated expectation<pre><code>- !Stringified '{''color'': ''brown'', ''legs'': 4}'\n- !Stringified '{''fur'': False, ''env'': ''water''}'\n</code></pre> <p>Notes:</p> <ul> <li>Values object must be an instance of <code>collections.abc.Iterable</code>.</li> <li>Any supported expectation definition can be used in the definition.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#uniformunordereddef","title":"<code>UniformUnorderedDef</code>","text":"<p><code>UniformUnorderedDef</code> is a slight modification of <code>UniformOrderedDef</code>. The difference is that it produces an <code>Unordered</code> expectation.</p> <p>Example usage:</p> Python<pre><code>object_ = [\n    {'color': 'brown', 'legs': 4},\n    {'fur': False, 'env': 'water'},\n]\n\ndefinition = UniformUnorderedDef(StringifiedDef)\n</code></pre> Generated expectation<pre><code>!Unordered\n- !Stringified '{''color'': ''brown'', ''legs'': 4}'\n- !Stringified '{''fur'': False, ''env'': ''water''}'\n</code></pre> <p>Notes:</p> <ul> <li>Values object must be an instance of <code>collections.abc.Iterable</code>.</li> <li>Any supported expectation definition can be used in the definition.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#objectattributesdef","title":"<code>ObjectAttributesDef</code>","text":"<p>The <code>ObjectAttributesDef</code> definition is used to generate an <code>ObjectAttributes</code> expectation. This definition maps attribute names from the values object to definitions that will be used to create expectations for their corresponding values.</p> <p>Example usage:</p> Python<pre><code>object_ = Munch(\n    xyz={'color': 'brown', 'legs': 4},\n    another='anything',\n    abc={'fur': False, 'env': 'water'},\n)\ndefinition = ObjectAttributesDef(\n    {\n        'abc': EqualityDef,\n        'xyz': StringifiedDef,\n    },\n)\n</code></pre> Generated expectation<pre><code>!ObjectAttributes\nabc:\n  env: water\n  fur: false\nxyz: !Stringified '{''color'': ''brown'', ''legs'': 4}'\n</code></pre> <p>Notes:</p> <ul> <li>The values object can be of any type.</li> <li>The values object must contain at least the attributes specified in the definition (it may contain more).</li> <li>The order of keys in mappings does not matter.</li> <li>Any supported expectation definition can be used as the value in the definition.</li> <li>Checking whether an attribute exists in the values object is done using the <code>hasattr</code> function.</li> <li>Values from the values object are extracted using <code>getattr(object_, key_from_definition)</code>.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#withtypedef","title":"<code>WithTypeDef</code>","text":"<p>The <code>WithTypeDef</code> definition generates a <code>WithType</code> expectation. It holds a definition that will be used to create the inner expectation. The constructor includes a keyword-only parameter that determines whether the values object module shall be included in the expectation (defaulting to <code>True</code>).</p> <p>Example usage:</p> Python<pre><code>object_ = Munch(\n    xyz={'color': 'brown', 'legs': 4},\n    another='anything',\n    abc={'fur': False, 'env': 'water'},\n)\ndefinition = WithTypeDef(\n    ObjectAttributesDef(\n        {\n            'abc': EqualityDef,\n            'xyz': StringifiedDef,\n        },\n    ),\n    include_module=True,\n)\n</code></pre> Generated expectation<pre><code>!WithType\nexpectation: !ObjectAttributes\n  abc:\n    env: water\n    fur: false\n  xyz: !Stringified '{''color'': ''brown'', ''legs'': 4}'\nexpected_type_module: munch\nexpected_type_name: Munch\n</code></pre> <p>Notes:</p> <ul> <li>The values object can be of any type.</li> <li>Any supported expectation definition can be used as the value in the definition.</li> <li>If <code>include_module</code> is set to <code>False</code>, the expected module name will be set to <code>None</code>.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#uniondef","title":"<code>UnionDef</code>","text":"<p>The <code>UnionDef</code> is used when the value can be of different kinds, each requiring a different definition. The expectation will be created using the first definition that is applicable for the provided values object.</p> <p>Example usage:</p> Python<pre><code>object_ = [\n    Munch(abc='something'),\n    123,\n    Munch(xyz=True),\n]\ndefinition = UniformOrderedDef(\n    UnionDef(\n        ObjectAttributesDef({'abc': EqualityDef}),\n        ObjectAttributesDef({'xyz': StringifiedDef}),\n        StringifiedDef,\n    ),\n)\n</code></pre> Generated expectation<pre><code>- !ObjectAttributes\n  abc: something\n- !Stringified '123'\n- !ObjectAttributes\n  xyz: !Stringified 'True'\n</code></pre> <p>Notes:</p> <ul> <li>The values object can be of any type.</li> <li>Any supported expectation definition can be used as values in the definition.</li> </ul>"},{"location":"assert_object/generating_expectation/10.definition/#oftypedef","title":"<code>OfTypeDef</code>","text":"<p>The <code>OfTypeDef</code> is particularly useful in combination with <code>UnionDef</code>. It generates an expectation only if the values object is of a specific type (or its subtype). The expectation itself is generated using the provided definition.</p> <p>Example usage:</p> Python<pre><code>object_ = [\n    Munch(abc='something'),\n    123,\n    Munch(xyz=True),\n    False,\n]\ndefinition = UniformOrderedDef(\n    UnionDef(\n        OfTypeDef(int, StringifiedDef),\n        OfTypeDef(Munch, UniformMappingDef(EqualityDef, StringifiedDef)),\n    ),\n)\n</code></pre> Generated expectation<pre><code>- abc: !Stringified 'something'\n- !Stringified '123'\n- xyz: !Stringified 'True'\n- !Stringified 'False'\n</code></pre> <p>Notes:</p> <ul> <li>The values object can be of any type.</li> <li>Any supported expectation definition can be used as values in the definition.</li> </ul>"},{"location":"assert_object/generating_expectation/20.generators/","title":"Generators","text":"<p>Generators are at the core of the <code>generators</code> submodule's business logic. They are responsible for generating expectations based on the values object and the given definition.</p> <p>Each generator must adhere to the following protocol:</p> Python<pre><code>class GeneratorProtocol(Protocol):\n    \"\"\"\n    Generates expectation from a given object according to a definition.\n    \"\"\"\n\n    definition: Any\n    generator_factory: 'type[GeneratorFactoryProtocol]'\n\n    def __init__(\n        self,\n        generator_factory: 'type[GeneratorFactoryProtocol]',\n        definition: Any,  # noqa: ANN401\n    ) -&gt; None: ...\n\n    @classmethod\n    def matches(cls, definition: Any) -&gt; bool:  # noqa: ANN401\n        \"\"\"\n        Determines whether the provided definition can be handled by this generator.\n\n        :param definition: the definition to be tested\n        \"\"\"\n\n    def generate_expectation(self, object_: Any) -&gt; Any:  # noqa: ANN401\n        \"\"\"\n        Generates an expectation from the given object.\n\n        :param object_: the object from which to generate an expectation\n        \"\"\"\n</code></pre>"},{"location":"assert_object/generating_expectation/20.generators/#generator-factories","title":"Generator Factories","text":"<p>When generating expectations, generators are created from definitions using factories. The factory maintains an ordered sequence of generator classes. When creating a generator for a specific definition, the factory iterates over the classes and uses the first one for which the <code>matches</code> method returns <code>True</code>.</p> <p>The module provides a <code>BuiltInGeneratorFactory</code> that includes all out-of-the-box generators. Additionally, there is a blank factory called <code>GeneratorFactory</code> that does not have any generators registered.</p> <p>To add a generator to the factory, use the <code>register_generator</code> class method with the following signature:</p> Python<pre><code>def register_generator(\n    generator: type[GeneratorProtocol],\n    *,\n    after: type[GeneratorProtocol] | None = None,\n    before: type[GeneratorProtocol] | None = None,\n) -&gt; None:\n</code></pre> <p>The generator is registered at the earliest possible position. If <code>after</code> and <code>before</code> parameters are not set, it is added to the beginning of the list to be matched when creating a generator for a definition. The <code>after</code> and <code>before</code> parameters allow you to specify constraints on the generator's position.</p> <p>When creating a subclass of a factory, it initially uses the same generators collection as its base class. However, once the first generator is registered, the collection from the base class is copied before adding new generators.</p>"}]}